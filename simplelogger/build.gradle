apply plugin: 'com.android.library'
apply plugin: 'kotlin-android'
apply plugin: 'maven-publish'
apply plugin: 'com.jfrog.bintray'
apply plugin: 'org.ajoberstar.grgit'
apply plugin: 'jacoco'

jacoco {
    toolVersion = "0.7.6.201602180812"
    reportsDir = file("$buildDir")
}

task jacocoTestReport(type: JacocoReport, dependsOn: ['testDebugUnitTest']) {

    reports {
        xml.enabled = false
        html.enabled = true
    }

    def excludes = [
            '**/R.class',
            '**/R$*.class',
            '**/BuildConfig.*',
            '**/Manifest*.*',
            '**/AndroidLogger.*'
    ]

    def kotlinDebugTree = fileTree(dir: "${buildDir}/tmp/kotlin-classes/debug", excludes: excludes)
    def mainSrc = "${project.projectDir}/src/test/kotlin"

    sourceDirectories = files([mainSrc])
    classDirectories = files([kotlinDebugTree])
    executionData = fileTree(dir: "$buildDir", includes: [
            "jacoco/testDebugUnitTest.exec",
            "outputs/code-coverage/connected/*coverage.ec"
    ])
}

android {
    compileSdkVersion 26
    buildToolsVersion "26.0.2"

    defaultConfig {
        minSdkVersion 15
        targetSdkVersion 26
        versionCode 1
        versionName "2.0.0"
        setProperty('archivesBaseName', "$archivesBaseName-$versionName")
        consumerProguardFiles 'proguard-rules.pro'
    }

    buildTypes {
        debug {
            testCoverageEnabled = true
        }
    }

    sourceSets{
        main.java.srcDirs += 'src/main/kotlin'
        test.java.srcDirs += 'src/test/kotlin'
    }
}

dependencies {
    testImplementation 'junit:junit:4.12'
    implementation "org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version"
}

tasks.withType(Test) {
    testLogging {
        events "passed", "skipped", "failed"
    }
}

task sourcesJar(type: Jar) {
    description "Generates sources jar file"
    from android.sourceSets.main.java.srcDirs
    classifier = 'sources'
}

afterEvaluate {
    tasks.assembleRelease.dependsOn sourcesJar
}

if (project.file('local.properties').exists()) {

    afterEvaluate{
        tasks.bintrayUpload.dependsOn assembleRelease, tagRelease
    }

    task checkGit {
        doLast {
            def status = grgit.status()
            if (!status.isClean()) {
                throw new GradleException("There are uncommitted files");
            }

            def currentBranch = grgit.branch.getCurrent()
            def currentBranchName = currentBranch.getName()
            println "Current branch is ${currentBranchName}"

            def trackingBranch = currentBranch.trackingBranch
            if (trackingBranch == null) {
                throw new GradleException("Push current branch ${currentBranchName}\nor set upstream branch");
            }
            def trackingBranchName = trackingBranch.getName()
            def log = grgit.log {
                range trackingBranchName, currentBranchName
            }
            if (log.size() > 0) {
                throw new GradleException("There are unpushed commits")
            }
        }
    }

    task tagRelease(dependsOn: checkGit) {
        description = 'Tags the current head with the project\'s version.'
        doLast {
            grgit.tag.add {
                name = android.defaultConfig.versionName
                message = "Release of ${android.defaultConfig.versionName}"
            }
        }
    }

    Properties properties = new Properties()
    properties.load(project.file('local.properties').newDataInputStream())

    publishing {
        publications {
            aar(MavenPublication) {
                groupId = properties.getProperty('publishing.groupId')
                artifactId project.name
                version = android.defaultConfig.versionName
                artifact "$buildDir/outputs/aar/$archivesBaseName-release.aar"
                artifact("${project.buildDir}/libs/${archivesBaseName}-sources.jar") {
                    classifier = 'sources'
                }
                pom.withXml {
                    def dependenciesNode = asNode().appendNode('dependencies')
                    configurations.compile.allDependencies.each {
                        if (!("unspecified".equalsIgnoreCase(it.name))) {
                            def dependencyNode = dependenciesNode.appendNode('dependency')
                            dependencyNode.appendNode('groupId', it.group)
                            dependencyNode.appendNode('artifactId', it.name)
                            dependencyNode.appendNode('version', it.version)
                        }
                    }
                }
            }
        }
    }

    bintray {
        user = properties.getProperty('bintray.user')
        key = properties.getProperty('bintray.apikey')
        publications = ['aar']
        pkg {
            repo = properties.getProperty('bintray.repo')
            name = project.name
            publish = true
            licenses = ['MIT']
            desc = 'A small android logging library'
            websiteUrl = properties.getProperty("bintray.websiteUrl")
            issueTrackerUrl = "${properties.getProperty('bintray.websiteUrl')}/issues"
            vcsUrl = "${properties.getProperty('bintray.websiteUrl')}.git"
            labels = ['android', 'logging', 'kotlin']
            version {
                name = android.defaultConfig.versionName
                released  = new Date()
                desc = 'simplelogger ' + android.defaultConfig.versionName
                vcsTag = android.defaultConfig.versionName
            }
        }
    }
}
